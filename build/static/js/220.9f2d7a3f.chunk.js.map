{"version":3,"file":"static/js/220.9f2d7a3f.chunk.js","mappings":"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","sources":["components/AccessControl.js","hooks/useApi.js","hooks/useNotification.js","components/DeleteConfirmDialog.js"],"sourcesContent":["import React from 'react';\nimport { Box, Typography, Paper } from '@mui/material';\nimport { usePermissions } from '../hooks/usePermissions';\nimport i18nService from '../services/i18nService';\n\nconst AccessControl = ({ \n  allowedRoles = [], \n  children, \n  fallback = null,\n  showMessage = true \n}) => {\n  const permissions = usePermissions();\n  \n  // Vérifier si l'utilisateur a un des rôles autorisés\n  const hasAccess = allowedRoles.some(role => {\n    switch (role) {\n      case 'SUPER_ADMIN':\n        return permissions.isSuperAdmin;\n      case 'ADMIN':\n        return permissions.isAdmin;\n      case 'MANAGER':\n        return permissions.isManager;\n      case 'SUPERVISEUR':\n        return permissions.isSuperviseur;\n      case 'COLLECTEUR_CULTE':\n        return permissions.isCollecteurCulte;\n      case 'COLLECTEUR_RESEAUX':\n        return permissions.isCollecteurReseaux;\n      default:\n        return false;\n    }\n  });\n\n  if (hasAccess) {\n    return children;\n  }\n\n  if (fallback) {\n    return fallback;\n  }\n\n  if (!showMessage) {\n    return null;\n  }\n\n  return (\n    <Box sx={{ \n      display: 'flex', \n      justifyContent: 'center', \n      alignItems: 'center', \n      minHeight: '50vh',\n      p: 3\n    }}>\n      <Paper elevation={3} sx={{ p: 4, textAlign: 'center', maxWidth: 500 }}>\n        <Typography variant=\"h5\" color=\"error\" gutterBottom>\n          {i18nService.t('errors.accessDenied')}\n        </Typography>\n        <Typography variant=\"body1\" color=\"text.secondary\" paragraph>\n          {i18nService.t('errors.insufficientPermissions')}\n        </Typography>\n        <Typography variant=\"body2\" color=\"text.secondary\">\n          {i18nService.t('errors.contactAdmin')}\n        </Typography>\n      </Paper>\n    </Box>\n  );\n};\n\nexport default AccessControl;\n","import { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport { handleApiError } from '../utils/errorHandler';\nimport { apiService } from '../services/apiService';\n\n// Cache global pour stocker les données\nconst cache = new Map();\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\nexport const useApi = (apiCall, dependencies = [], options = {}) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const cacheKey = useRef(null);\n  const abortController = useRef(null);\n\n  // Générer une clé de cache basée sur l'appel API et les dépendances\n  useEffect(() => {\n    cacheKey.current = JSON.stringify({ apiCall: apiCall.toString(), dependencies });\n  }, [apiCall, dependencies]);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      // Vérifier le cache\n      if (cache.has(cacheKey.current)) {\n        const cachedData = cache.get(cacheKey.current);\n        if (Date.now() - cachedData.timestamp < CACHE_DURATION) {\n          setData(cachedData.data);\n          setLoading(false);\n          return;\n        } else {\n          // Cache expiré, le supprimer\n          cache.delete(cacheKey.current);\n        }\n      }\n\n      // Annuler la requête précédente si elle existe\n      if (abortController.current) {\n        abortController.current.abort();\n      }\n\n      // Créer un nouveau contrôleur d'annulation\n      abortController.current = new AbortController();\n\n      setLoading(true);\n      setError(null);\n\n      try {\n        const result = await apiCall();\n        \n        // Vérifier si la requête n'a pas été annulée\n        if (!abortController.current.signal.aborted) {\n          const responseData = result.data?.data || result.data || result;\n          setData(responseData);\n          setError(null);\n\n          // Mettre en cache\n          cache.set(cacheKey.current, {\n            data: responseData,\n            timestamp: Date.now()\n          });\n        }\n      } catch (err) {\n        if (!abortController.current.signal.aborted) {\n          setError(err.message || 'Une erreur est survenue');\n          setData(null);\n        }\n      } finally {\n        if (!abortController.current.signal.aborted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () => {\n      if (abortController.current) {\n        abortController.current.abort();\n      }\n    };\n  }, [apiCall, dependencies]);\n\n  // Fonction pour forcer le rafraîchissement\n  const refetch = async () => {\n    if (cacheKey.current) {\n      cache.delete(cacheKey.current);\n    }\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await apiCall();\n      const responseData = result.data?.data || result.data || result;\n      setData(responseData);\n      \n      // Mettre en cache\n      cache.set(cacheKey.current, {\n        data: responseData,\n        timestamp: Date.now()\n      });\n    } catch (err) {\n      setError(err.message || 'Une erreur est survenue');\n      setData(null);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return { data, loading, error, refetch };\n};\n\n// Hook spécialisé pour les statistiques avec cache plus long\nexport const useStatsApi = (apiCall, dependencies = []) => {\n  return useApi(apiCall, dependencies, { cacheDuration: 10 * 60 * 1000 }); // 10 minutes\n};\n\n// Fonction utilitaire pour vider le cache\nexport const clearCache = () => {\n  cache.clear();\n};\n\n// Fonction utilitaire pour vider le cache d'une clé spécifique\nexport const clearCacheKey = (key) => {\n  cache.delete(key);\n};\n\n// Hook pour les utilisateurs\nexport const useUsers = (params = {}) => {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Stabiliser les paramètres pour éviter les rechargements inutiles\n  const paramsString = JSON.stringify(params);\n  const stableParams = useMemo(() => params, [paramsString]);\n\n  const fetchUsers = useCallback(async (fetchParams = stableParams) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.users.getAll(fetchParams);\n      setUsers(response.data?.data || response.data || []);\n      return response;\n    } catch (err) {\n      // Ne jamais exposer les erreurs techniques à l'utilisateur\n      const processedError = handleApiError(err, 'le chargement des utilisateurs');\n      setError(processedError.message);\n      // Créer une nouvelle erreur avec le message sécurisé\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [stableParams]);\n\n  // Charger les utilisateurs seulement au montage initial ou quand les paramètres changent\n  useEffect(() => {\n    if (Object.keys(stableParams).length > 0) {\n      fetchUsers();\n    }\n  }, [stableParams, fetchUsers]); // Ajouter fetchUsers comme dépendance\n\n  const createUser = useCallback(async (userData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.users.create(userData);\n      await fetchUsers(); // Recharger la liste\n      return response;\n    } catch (err) {\n      // Ne jamais exposer les erreurs techniques à l'utilisateur\n      const processedError = handleApiError(err, 'la création de l\\'utilisateur');\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchUsers]);\n\n  const updateUser = useCallback(async (id, userData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.users.update(id, userData);\n      await fetchUsers(); // Recharger la liste\n      return response;\n    } catch (err) {\n      // Ne jamais exposer les erreurs techniques à l'utilisateur\n      const processedError = handleApiError(err, 'la mise à jour de l\\'utilisateur');\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchUsers]);\n\n  const deleteUser = useCallback(async (id) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.users.delete(id);\n      await fetchUsers(); // Recharger la liste\n      return response;\n    } catch (err) {\n      // Ne jamais exposer les erreurs techniques à l'utilisateur\n      const processedError = handleApiError(err, 'la suppression de l\\'utilisateur');\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchUsers]);\n\n  return {\n    users,\n    loading,\n    error,\n    fetchUsers,\n    createUser,\n    updateUser,\n    deleteUser\n  };\n};\n\n// Hook pour les réseaux\nexport const useNetworks = (params = {}) => {\n  const [networks, setNetworks] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Mémoriser les paramètres pour éviter les re-renders inutiles\n  const stableParams = useMemo(() => {\n    const { churchId, ...otherParams } = params;\n    return {\n      churchId: churchId || null,\n      ...otherParams\n    };\n  }, [params.churchId, JSON.stringify(params)]);\n\n  // Fonction pour récupérer les réseaux\n  const fetchNetworks = useCallback(async (fetchParams = stableParams) => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      // Vérifier que les paramètres sont valides\n      if (!fetchParams || !fetchParams.churchId) {\n        setNetworks([]);\n        setError(null);\n        return;\n      }\n\n      // Appel API direct sans cache pour garantir la fraîcheur des données\n      const response = await apiService.networks.getAll(fetchParams);\n      \n      // Traiter la réponse Axios\n      if (response.data) {\n        const networkData = response.data.data || response.data;\n        setNetworks(Array.isArray(networkData) ? networkData : []);\n        setError(null);\n      } else {\n        setError('Aucune donnée reçue du serveur');\n        setNetworks([]);\n      }\n    } catch (err) {\n      \n      let errorMessage = 'Erreur lors du chargement des réseaux';\n      \n      // Traiter différents types d'erreurs\n      if (err.response) {\n        // Erreur HTTP du serveur\n        errorMessage = err.response.data?.message || `Erreur ${err.response.status}: ${err.response.statusText}`;\n      } else if (err.request) {\n        // Erreur de réseau\n        errorMessage = 'Erreur de connexion au serveur';\n      } else {\n        // Autre erreur\n        errorMessage = err.message || 'Erreur inconnue';\n      }\n      \n      setError(errorMessage);\n      setNetworks([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [stableParams]);\n\n  // Charger les réseaux au montage et quand les paramètres changent\n  useEffect(() => {\n    // Vérifier que les paramètres sont valides et contiennent au moins churchId\n    if (stableParams && stableParams.churchId) {\n      fetchNetworks();\n    } else {\n      setNetworks([]);\n      setError(null);\n    }\n  }, [stableParams, fetchNetworks]);\n\n  // Fonction de création avec rechargement immédiat\n  const createNetwork = useCallback(async (networkData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const response = await apiService.networks.create(networkData);\n      \n      // Recharger immédiatement la liste pour refléter les changements\n      await fetchNetworks();\n      \n      return response;\n    } catch (err) {\n      const processedError = handleApiError(err, 'la création du réseau');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchNetworks]);\n\n  // Fonction de mise à jour avec rechargement immédiat\n  const updateNetwork = useCallback(async (id, networkData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const response = await apiService.networks.update(id, networkData);\n      \n      // Recharger immédiatement la liste pour refléter les changements\n      await fetchNetworks();\n      \n      return response;\n    } catch (err) {\n      const processedError = handleApiError(err, 'la mise à jour du réseau');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchNetworks]);\n\n  // Fonction de suppression avec rechargement immédiat\n  const deleteNetwork = useCallback(async (id) => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const response = await apiService.networks.delete(id);\n      \n      // Recharger immédiatement la liste pour refléter les changements\n      await fetchNetworks();\n      \n      return response;\n    } catch (err) {\n      const processedError = handleApiError(err, 'la suppression du réseau');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchNetworks]);\n\n  return {\n    networks,\n    loading,\n    error,\n    fetchNetworks,\n    createNetwork,\n    updateNetwork,\n    deleteNetwork\n  };\n};\n\n// Hook pour les églises\nexport const useChurches = () => {\n  const [churches, setChurches] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const fetchChurches = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.churches.getAll();\n      setChurches(response.data?.data || response.data || []);\n      return response;\n    } catch (err) {\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const processedError = handleApiError(err, 'Erreur lors du chargement des églises');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Charger les églises au montage initial\n  useEffect(() => {\n    fetchChurches();\n  }, [fetchChurches]);\n\n  return {\n    churches,\n    loading,\n    error,\n    fetchChurches\n  };\n};\n\n// Hook pour les services\nexport const useServices = () => {\n  const [services, setServices] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const fetchServices = useCallback(async (params) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.services.getAll(params);\n      setServices(response.data?.data || response.data || []);\n      return response;\n    } catch (err) {\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const processedError = handleApiError(err, 'Erreur lors du chargement des services');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  const createService = useCallback(async (serviceData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.services.create(serviceData);\n      await fetchServices(); // Recharger la liste\n      return response;\n    } catch (err) {\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const processedError = handleApiError(err, 'Erreur lors de la création');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchServices]);\n\n  const updateService = useCallback(async (id, serviceData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.services.update(id, serviceData);\n      await fetchServices(); // Recharger la liste\n      return response;\n    } catch (err) {\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const processedError = handleApiError(err, 'Erreur lors de la mise à jour');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchServices]);\n\n  const deleteService = useCallback(async (id) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.services.delete(id);\n      await fetchServices(); // Recharger la liste\n      return response;\n    } catch (err) {\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const processedError = handleApiError(err, 'Erreur lors de la suppression');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchServices]);\n\n  return {\n    services,\n    loading,\n    error,\n    fetchServices,\n    createService,\n    updateService,\n    deleteService\n  };\n};\n\n// Hook pour les opérations CRUD\nexport const useCrud = (apiService) => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const create = useCallback(async (data) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.create(data);\n      return response;\n    } catch (err) {\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const processedError = handleApiError(err, 'Erreur lors de la création');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [apiService]);\n\n  const update = useCallback(async (id, data) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.update(id, data);\n      return response;\n    } catch (err) {\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const processedError = handleApiError(err, 'Erreur lors de la mise à jour');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [apiService]);\n\n  const remove = useCallback(async (id) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiService.delete(id);\n      return response;\n    } catch (err) {\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const processedError = handleApiError(err, 'Erreur lors de la suppression');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [apiService]);\n\n  return {\n    loading,\n    error,\n    create,\n    update,\n    remove\n  };\n};\n\n// Hook spécialisé pour les listes avec pagination\nexport const useApiList = (apiMethod, initialParams = {}) => {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [params, setParams] = useState(initialParams);\n  const [pagination, setPagination] = useState({\n    page: 1,\n    limit: 10,\n    total: 0\n  });\n\n  const fetchData = useCallback(async (newParams = {}) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const updatedParams = { ...params, ...newParams };\n      setParams(updatedParams);\n      \n      const response = await apiMethod(updatedParams);\n      setData(response.data);\n      \n      if (response.pagination) {\n        setPagination(response.pagination);\n      }\n      \n      return response;\n    } catch (err) {\n      // Ne pas définir d'erreur globale - l'erreur sera gérée localement\n      const processedError = handleApiError(err, 'Une erreur est survenue');\n      const secureError = new Error(processedError.message);\n      secureError.userMessage = processedError.message;\n      throw secureError;\n    } finally {\n      setLoading(false);\n    }\n  }, [apiMethod, params]);\n\n  const refetch = useCallback(() => {\n    return fetchData();\n  }, [fetchData]);\n\n  const updateParams = useCallback((newParams) => {\n    setParams(prev => ({ ...prev, ...newParams }));\n  }, []);\n\n  return {\n    data,\n    loading,\n    error,\n    pagination,\n    params,\n    fetchData,\n    refetch,\n    updateParams\n  };\n}; ","import { useState, useCallback } from 'react';\r\n\r\nexport const useNotification = () => {\r\n  const [notification, setNotification] = useState({\r\n    open: false,\r\n    message: '',\r\n    severity: 'info' // 'success', 'error', 'warning', 'info'\r\n  });\r\n\r\n  const showNotification = useCallback((message, severity = 'info') => {\r\n    setNotification({\r\n      open: true,\r\n      message,\r\n      severity\r\n    });\r\n  }, []);\r\n\r\n  const hideNotification = useCallback(() => {\r\n    setNotification(prev => ({\r\n      ...prev,\r\n      open: false\r\n    }));\r\n  }, []);\r\n\r\n  const showSuccess = useCallback((message) => {\r\n    showNotification(message, 'success');\r\n  }, [showNotification]);\r\n\r\n  const showError = useCallback((message) => {\r\n    showNotification(message, 'error');\r\n  }, [showNotification]);\r\n\r\n  const showWarning = useCallback((message) => {\r\n    showNotification(message, 'warning');\r\n  }, [showNotification]);\r\n\r\n  const showInfo = useCallback((message) => {\r\n    showNotification(message, 'info');\r\n  }, [showNotification]);\r\n\r\n  return {\r\n    notification,\r\n    showNotification,\r\n    hideNotification,\r\n    showSuccess,\r\n    showError,\r\n    showWarning,\r\n    showInfo\r\n  };\r\n};","import React from 'react';\nimport {\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogContentText,\n  DialogActions,\n  Button\n} from '@mui/material';\nimport i18nService from '../services/i18nService';\n\nconst DeleteConfirmDialog = ({\n  open,\n  onClose,\n  onConfirm,\n  title,\n  content\n}) => {\n  return (\n    <Dialog\n      open={open}\n      onClose={onClose}\n      aria-labelledby=\"alert-dialog-title\"\n      aria-describedby=\"alert-dialog-description\"\n    >\n      <DialogTitle id=\"alert-dialog-title\">\n        {title}\n      </DialogTitle>\n      <DialogContent>\n        <DialogContentText id=\"alert-dialog-description\">\n          {content}\n        </DialogContentText>\n      </DialogContent>\n      <DialogActions>\n        <Button onClick={onClose}>{i18nService.t('common.actions.cancel')}</Button>\n        <Button\n          onClick={onConfirm}\n          color=\"error\"\n          variant=\"contained\"\n          autoFocus\n        >\n          {i18nService.t('common.actions.delete')}\n        </Button>\n      </DialogActions>\n    </Dialog>\n  );\n};\n\nexport default DeleteConfirmDialog;\n"],"names":["_ref","allowedRoles","children","fallback","showMessage","permissions","usePermissions","some","role","isSuperAdmin","isAdmin","isManager","isSuperviseur","isCollecteurCulte","isCollecteurReseaux","_jsx","Box","sx","display","justifyContent","alignItems","minHeight","p","_jsxs","Paper","elevation","textAlign","maxWidth","Typography","variant","color","gutterBottom","i18nService","t","paragraph","useUsers","Map","params","arguments","length","undefined","users","setUsers","useState","loading","setLoading","error","setError","paramsString","JSON","stringify","stableParams","useMemo","fetchUsers","useCallback","async","fetchParams","_response$data","response","apiService","getAll","data","err","processedError","handleApiError","message","secureError","Error","userMessage","useEffect","Object","keys","createUser","create","userData","updateUser","id","update","deleteUser","delete","useNetworks","networks","setNetworks","churchId","otherParams","_objectWithoutProperties","_excluded","_objectSpread","fetchNetworks","networkData","Array","isArray","errorMessage","_err$response$data","concat","status","statusText","request","createNetwork","updateNetwork","deleteNetwork","useChurches","churches","setChurches","fetchChurches","_response$data2","useServices","services","setServices","fetchServices","_response$data3","createService","serviceData","updateService","deleteService","useNotification","notification","setNotification","open","severity","showNotification","hideNotification","prev","showSuccess","showError","showWarning","showInfo","onClose","onConfirm","title","content","Dialog","DialogTitle","DialogContent","DialogContentText","DialogActions","Button","onClick","autoFocus"],"sourceRoot":""}